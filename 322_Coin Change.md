## 思路
利用 hash 表缓存计算过程，以避免重复计算带来的时间复杂度提升。

## 关键
+ dp[0] 的初始值设置为0.
+ 在比较每个和与缺一份面值的差异时，要对缺一份面值的结果默认都加1。这个加1暂时无法解释，但就是有这种规律.
对于加1的解释
+ 因为 dp\[i-c] 正好减去的是一个面值，所以相当于少了一种方式，因此通过加1的方式加上。这里表示对面值的中和。

## 涉及的情况
对 hash 表的处理
+ 初始化
|dp\[0]|dp\[1]|dp\[2]|dp\[3]|dp\[4]|dp\[5]|dp\[6]|dp\[7]|dp\[8]|dp\[9]|dp\[10]|dp\[11]|
|---|---|---|---|---|---|---|---|---|---|---|---|
|0|12|12|12|12|12|12|12|12|12|12|12|
+ 对面值的初始化

|dp\[0]|dp\[1]|dp\[2]|dp\[3]|dp\[4]|dp\[5]|dp\[6]|dp\[7]|dp\[8]|dp\[9]|dp\[10]|dp\[11]|
|---|---|---|---|---|---|---|---|---|---|---|---|
|0|**1**|**1**|2|2|**1**|2|2|3|3|2|3|

+ 无法构成 dp[amount] 的情况判别
```
if dp[amount] == (amount+1):
    return -1
```
## 答案
