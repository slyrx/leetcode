# 题目描述

# 解题思路
初始时，窗口的左边界和右边界都指向字符串的开头。然后，我们将右边界逐步向右移动，每次移动时更新计数器并检查窗口内的字符是否满足平衡要求。
如果窗口内的字符满足平衡要求，即每个字符的出现次数不超过目标平衡子串长度 m，则记录当前子串的长度，并尝试缩小窗口，即将左边界向右移动，直到窗口不再满足平衡要求为止。

在给定的代码中，没有显式处理替换不成功的情况。这段代码的目的是替换子串，使得字符串中每个字符的出现次数都不超过给定的阈值。
当找到满足要求的子串后，会更新答案 ans 的值为当前子串的长度。如果无法找到满足要求的子串，则返回原始字符串的长度作为答案。

cnt 表示总的字符统计，可以分成 2 个部分，平衡的字符和不平衡的字符。
cnt[c]-- 的目的是当字符进入窗口时，我们需要将其在计数器中的计数减 1，表示该字符已经被使用了。

# 实现代码

```golang
func balancedString(s string) int {
    cnt, m := ['X']int{}, len(s)/4  // 创建一个计数器数组 cnt，存储每个字符的出现次数；m 为目标平衡子串长度
    for _, val := range s {
        cnt[val]++  // 统计每个字符的出现次数
    }
    
    // 如果每个字符的出现次数都等于目标平衡子串长度，则整个字符串已经平衡，不需要进行操作，直接返回 0
    if cnt['Q'] == m && cnt['W'] == m && cnt['E'] == m && cnt['R'] == m {
        return 0
    }
    
    ans, left := len(s), 0  // 初始化结果 ans 为字符串长度，left 为滑动窗口的左边界
    
    // 遍历字符串 s 中的每个字符
    for right, c := range s {
        cnt[c]--  // 将当前字符从计数器中减去, 这里将元素划到了 cnt 里不平衡的部分
        
        // 当滑动窗口内的字符满足平衡要求时，不断缩小窗口直到不满足平衡要求为止， 下面的判断是判断的 cnt 里平衡的部分，获得结果后
        for cnt['Q'] <= m && cnt['W'] <= m && cnt['E'] <= m && cnt['R'] <= m {
            ans = min(ans, right-left+1)  // 更新结果 ans，取最小值
            cnt[s[left]]++  // 将左边界字符添加回计数器中
            left++  // 缩小窗口，左边界右移
        }
    }
    
    return ans  // 返回最小操作次数
}

// 返回两个整数中的较小值
func min(a, b int) int {
    if a > b {
        return b
    }
    return a
}


```

# 时间复杂度
O(N)
# 空间复杂度
O(1)
